%\VignetteIndexEntry{Quick Start Guide}
%\VignettePackage{MARSS}
\documentclass[12pt]{article}
\usepackage[landscape]{geometry}
\usepackage{hyperref}

%\input{tex/mathdefs}
\usepackage{amsmath} % the standard math package
%%%% bold maths symbol system:
\def\AA{\mbox{$\mathbf A$}}
\def\aa{\mbox{$\mathbf a$}}
\def\BB{\mbox{$\mathbf B$}}
\def\bb{\mbox{$\mathbf b$}}
\def\CC{\mbox{$\mathbf C$}}
\def\cc{\mbox{$\mathbf c$}}
\def\DD{\mbox{$\mathbf D$}}
\def\dd{\mbox{$\mathbf d$}}
\def\EE{\mbox{$\mathbf E$}}
\def\ee{\mbox{$\mathbf e$}}
\def\FF{\mbox{$\mathbf F$}}
\def\ff{\mbox{$\mathbf f$}}
\def\gg{\mbox{$\mathbf g$}}
\def\GG{\mbox{$\mathbf G$}}
\def\HH{\mbox{$\mathbf H$}}
\def\II{\mbox{$\mathbf I$}}
\def\LL{\mbox{$\mathbf L$}}
\def\MM{\mbox{$\mathbf M$}}
\def\mm{\mbox{$\mathbf m$}}
\def\OO{\mbox{$\mathbf O$}}
\def\PP{\mbox{$\mathbf P$}}
\def\pp{\mbox{$\mathbf p$}}
\def\QQ{\mbox{$\mathbf Q$}}
\def\qq{\mbox{$\mathbf q$}}
\def\RR{\mbox{$\mathbf R$}}
\def\rr{\mbox{$\mathbf r$}}
\def\UU{\mbox{$\mathbf U$}}
\def\uu{\mbox{$\mathbf u$}}
\def\VV{\mbox{$\mathbf V$}}
\def\vv{\mbox{$\mathbf v$}}
\def\WW{\mbox{$\mathbf W$}}
\def\ww{\mbox{$\mathbf w$}}
\def\XX{\mbox{$\mathbf X$}}
\def\xx{\mbox{$\mathbf x$}}
\def\YY{\mbox{$\mathbf Y$}}
\def\yy{\mbox{$\mathbf y$}}
\def\ZZ{\mbox{$\mathbf Z$}}
\def\zz{\mbox{$\mathbf z$}}
\def\et{\mbox{\boldmath $\eta$}}
\def\ep{\mbox{\boldmath $\epsilon$}}
\def\pipi{\mbox{\boldmath $\pi$}}
\def\uupsilon{\pmb{\upsilon}}
\def\llambda{\pmb{\lambda}}
\def\bbeta{\pmb{\beta}}
\def\aalpha{\pmb{\alpha}}
\def\zzeta{\pmb{\zeta}}
\def\etaeta{\mbox{\boldmath $\eta$}}
\def\xixi{\mbox{\boldmath $\xi$}}
\def\PI{\mbox{\boldmath $\mathrm{\Pi}$}}
\def\LAM{\mbox{\boldmath $\mathrm{\Lambda}$}}
\def\GAM{\mbox{\boldmath $\mathrm{\Gamma}$}}
\def\SI{\mbox{\boldmath $\mathrm{\Sigma}$}}
\def\TH{\mbox{\boldmath $\mathrm{\Theta}$}}
\def\PH{\mbox{\boldmath $\mathrm{\Phi}$}}
\def\zer{\mbox{\boldmath $0$}}
\def\vec{\,\textup{\textrm{vec}}}
\def\var{\,\textup{\textrm{var}}}
\def\cov{\,\textup{\textrm{cov}}}
\def\MVN{\,\textup{\textrm{MVN}}}
\def\AIC{\,\textup{\textrm{AIC}}}
\def\E{\,\textup{\textrm{E}}}
\def\Lik{\,\textup{\textrm{L}}}
\def\N{\,\textup{\textrm{N}}}
\def\R{R}

\title{Quick Start Guide}
\begin{document}
\SweaveOpts{concordance=FALSE}
<<RUNFIRST, echo=FALSE>>=
options(prompt=" ", continue=" ")
@
\section*{MARSS Quick Start Guide}
The default MARSS model (\verb@form="marxss"@) is written as follows:
\begin{equation}\label{eqn:marss}
\begin{gathered}
\xx_t = \BB_t\xx_{t-1} + \uu_t + \CC_t\cc_t + \ww_t, \text{ where } \ww_t \sim \MVN(0,\QQ_t)\\
\yy_t = \ZZ_t\xx_t + \aa_t + \DD_t\dd_t + \vv_t, \text{ where } \vv_t \sim \MVN(0,\RR_t)\\
\xx_1 \sim \MVN(\pipi,\LAM) \text{ or } \xx_0 \sim \MVN(\pipi,\LAM)
\end{gathered}
\end{equation}
$\cc$ and $\dd$ are inputs (aka, exogenous variables or covariates or indicator variables) and must have no missing values.  They are not treated as `data' in the likelihood but as inputs.  The MARSS package is designed to handle linear constraints within the parameter matrices (the $\BB$, $\uu$, $\CC$, $\QQ$, $\ZZ$, $\aa$, $\DD$, $\RR$, $\pipi$, and $\LAM$)).  Linear constraint means you can write the elements of the matrix as a linear equation of all the other elements, although typically each matrix element is just a fixed or estimated value.

Model specification is based one-to-one on the MARSS equation above.  Many of the parameter elements will be fixed or zero and others will be shared (equal) within a matrix.  The following shows an example of a mean-reverting random walk model with three observation time series:
\begin{gather*}
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_t
= \begin{bmatrix}b&0\\ 0&b\end{bmatrix}
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_{t-1}
+ \begin{bmatrix}w_1\\ w_2\end{bmatrix}_t, \quad 
\begin{bmatrix}w_1\\ w_2\end{bmatrix}_t \sim \MVN\begin{pmatrix}\begin{bmatrix}0\\0\end{bmatrix},\begin{bmatrix}q_{11}&q_{12}\\ q_{12}&q_{22}\end{bmatrix} \end{pmatrix}, \quad
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_0 \sim \MVN\begin{pmatrix}\begin{bmatrix}0\\ 0\end{bmatrix},\begin{bmatrix}1&0\\ 0&1\end{bmatrix} \end{pmatrix} \\
\\
\begin{bmatrix}y_1\\y_2\\y_3\end{bmatrix}_t
= \begin{bmatrix}1&1\\ 0&1\\ 1&0\end{bmatrix}
\begin{bmatrix}x_1\\x_2\end{bmatrix}_t
+ \begin{bmatrix}v_1\\ v_2\\ v_3\end{bmatrix}_t,\quad 
\begin{bmatrix}v_1\\ v_2\\ v_3\end{bmatrix}_t \sim MVN\begin{pmatrix}\begin{bmatrix}a_1\\ 0\\ 0\end{bmatrix},
 \begin{bmatrix}r_{11}&0&0\\ 0&r&0\\ 0&0&r\end{bmatrix} \end{pmatrix} 
\end{gather*}

To fit this with MARSS, we translate this model as written mathematically into an equivalent matrix (or array if time-varying) in R. Matrices that combine fixed and estimated values are specified using a list matrix with numerical values for fixed values and  character names for the estimated values. The following shows how to specify the model above.
<<model.spec, eval=FALSE>>=
B1=matrix(list("b",0,0,"b"),2,2)
U1=matrix(0,2,1)
Q1=matrix(c("q11","q12","q12","q22"),2,2)
Z1=matrix(c(1,0,1,1,1,0),3,2)
A1=matrix(list("a1",0,0),3,1)
R1=matrix(list("r11",0,0,0,"r",0,0,0,"r"),3,3)
pi1=matrix(0,2,1); V1=diag(1,2)
model.list=list(B=B1,U=U1,Q=Q1,Z=Z1,A=A1,R=R1,x0=pi1,V0=V1,tinitx=0)
@
Try printing these out and you will see the one-to-one correspondence between the model in R and the math version of the model.  BTW, your model can have simple linear constraints within the matrix elements.  In that case, your matrix element might have $1+2a+3b$ and you specify this  using \verb@"1+2*a+3*b"@, instead of simply a numerical value or name of an estimated value.

For \verb@form="marxss"@ (the default), matrix names in the model list must be B, U, C, c, Q, Z, A, D, d, R, x0, and V0, just like in equation \eqref{eqn:marss}.  The \verb@tinitx@ element tells MARSS whether the initial state for $x$ is at $t=1$ (\verb@tinitx=1@) or $t=0$ (\verb@tinitx=0@).   The data must be entered as a $n \times T$ matrix; a dataframe is not a matrix nor is a vector nor is a time-series object.  MARSS has a number of text shortcuts for common parameter forms, such as ``diagonal and unequal''; see the User Guide for the possible shortcuts. You can leave off matrix names and the defaults will be used. Type ?MARSS.marxss to see the defaults for \verb@form="marxss"@.

The call to MARSS is 
<<marss.call, eval=FALSE>>=
fit=MARSS(data, model=model.list)
@
The \verb@R@, \verb@Q@ and \verb@V0@ variances can be set to zero to specify partially deterministic systems.  This allows you to write MAR-p models in MARSS form for example. See the User Guide for examples.  Type \verb@?MARSS@ at the command line for more info.

\section*{Important}
\begin{itemize}
  \item Specification of a properly constrained model with a unique solution is the responsibility of the user because MARSS has no way to tell if you have specified an insufficiently constrained model.
  \item The code in the MARSS package is not particularly fast and EM algorithms are famously slow.  You can try method="BFGS" and see if that is faster.  For some models, it will be much faster and for others, much slower.
\end{itemize}

\section*{Time-varying parameters and inputs}
The default model form (\verb@form="marxss"@) allows you to pass in an array of $T$ matrices for a time-varying parameter ($T$ is the number of time-steps in your data and is the 3rd dimension in the array):  
%\begin{equation}\label{qeq:MARSS.ex.vec}
\begin{equation}\label{qeq:MARSS.tv}
\begin{gathered}
\xx_t = \BB_t\xx_{t-1} + \uu_t + \CC_t\cc_t + \ww_t, \quad
\WW_t \sim \MVN(0,\QQ_t)\\
\yy_t = \ZZ_t\xx_t + \aa_t + \DD_t\dd_t + \vv_t, \quad
\VV_t \sim \MVN(0,\RR_t)\\
\xx_{t_0} \sim \MVN(\pipi,\LAM)
\end{gathered}
\end{equation}
Zeros are allowed on the diagonals of $\QQ$, $\RR$ and $\LAM$.  NOTE(!!), the time indexing.  Make sure you enter your arrays such that the right parameter (or input) at time $t$ lines up with $\xx_t$, e.g. it is common for state equations to have $\BB_{t-1}$ lined up with $\xx_t$ so you might need to enter the $\BB$ array such that your $\BB_{t-1}$ is entered at \verb@Bt[,,t]@ in the R code.

The length of the 3rd dimension must be the same as your data.  For example, say in your  mean-reverting random walk model (the example on the first page) you wanted $\BB(2,2)$ to be one value before $t=20$ and another value after but $\BB(1,1)$ to be time constant. You can pass in the following:
<<model.spec2, eval=FALSE>>=
TT=dim(data)[2]
B1=array(list(),dim=c(2,2,TT))
B1[,,1:20]=matrix(list("b",0,0,"b_1"),2,2)
B1[,,21:TT]=   matrix(list("b",0,0,"b_2"),2,2)
@
Notice the specification is one-to-one to your $\BB_t$ matrices on paper.

Inputs are specified in exactly the same manner.  $\CC$ and $\DD$ are the estimated parameters and $\cc$ and $\dd$ are the inputs.  Let's say you have temperature data and you want to include a linear effect of temperature that is different for each $\xx$ time series:
<<model.spec, eval=FALSE>>=
C1=matrix(c("temp1","temp2"),2,1)
model.list=list(B=B1,U=U1,C=C1,c=temp,Q=Q1,Z=Z1,A=A1,R=R1,x0=pi1,V0=V1,tinitx=0)
@
If you want a factor effect, then you'll need to recode your factor as a matrix with $T$ columns and a row for each factor.  Then you have 0 or 1 if that factor applies in time period $t$.  $\CC$ then has a column for each estimated factor effect.

\section*{Showing the model fits and getting the parameters}
There \verb@print@, \verb@coef@ and \verb@residuals@ functions for marssMLE objects.  However, a good place to start is to look at \verb@?print.MARSS@.  This will show you how to get a lot of standard output from your fitted model objects (marssMLE objects). It will also show you alternative ways to get that output and where that output is stored in the marssMLE object.  Type \verb@?coef.MARSS@ to see the different formats for displaying the estimated parameters.
 
\section*{The full time-varying model used in the MARSS EM algorithm}
Expectation-Maximization algorithms for unconstrained MARSS models have been around for many years.  What makes the EM algorithm in MARSS different is that it is a constrained algorithm.  In mathematical form, the model that is being fit with the package is
\begin{equation}\label{qeq:MARSS.ex.vec}
\begin{gathered}
\xx_t = (\xx_{t-1}^\top \otimes \II_m)\vec(\BB_t) + (\uu_t^\top \otimes \II_m)\vec(\UU_t) + \ww_t, \quad
\WW_t \sim \MVN(0,\QQ_t)\\
\yy_t = (\xx_t^\top \otimes \II_n)\vec(\ZZ_t) + (\aa_t^\top \otimes \II_n)\vec(\AA_t) + \vv_t, \quad
\VV_t \sim \MVN(0,\RR_t)\\
\xx_{t_0} = \pipi+\FF\ll, 
\LL \sim \MVN(0,\LAM)
\end{gathered}
\end{equation}

Each model parameter matrix, $\BB_t$, $\UU_t$, $\QQ_t$, $\ZZ_t$, $\AA_t$, and $\RR_t$, is written as a time-varying linear model, $\ff_t+\DD_t\mm$, where $\ff$ and $\DD$ are fully-known (not estimated and no missing values) and $\mm$ is a column vector of the estimates elements of the parameter matrix:
\begin{gather*}
\vec(\BB_t) = \ff_{t,b} + \DD_{t,b}\bbeta\quad
\vec(\UU_t) = \ff_{t,u} + \DD_{t,u}\uupsilon\quad
\vec(\QQ_t) = \ff_{t,q} + \DD_{t,q}\qq\\
\vec(\ZZ_t) = \ff_{t,z} + \DD_{t,z}\zzeta\quad
\vec(\AA_t) = \ff_{t,a} + \DD_{t,a}\aalpha\quad
\vec(\RR_t) = \ff_{t,r} + \DD_{t,r}\rr\\
\vec(\LAM)= \ff_\lambda+\DD_\lambda\llambda \quad
\vec(\pipi)= \ff_\pi+\DD_\pi\pp
\end{gather*}

The internal MARSS model specification (form=marss) is a list with the $\ff_t$ and $\DD_t$ matrices for each parameter.   
The output from fitting are the vectors, $\bbeta$, $\uupsilon$, etc.  The trick is to rewrite the user's linear multivariate problem into the general form (equation \ref{qeq:MARSS.ex.vec}).  MARSS does this using functions that take more familiar arguments as input and then constructs the $\ff_t$ and $\DD_t$ matrices.  Because the $\ff_t$ and $\DD_t$ can be whatever the user wants (assuming they are the right shape), this allows users to include covariates, trends (linear, sinusoidal, etc) or indicator variables in a variety of ways.  It also means that terms like $1+b+2c$ can appear in the parameter matrices.
  
Although the above form looks unusual, it is equivalent to the commonly seen form but leads to a log-likelihood function where all terms have form 
$\MM\mm$, where $\MM$ is a matrix and $\mm$ is a column vector of only the different estimated values.  This makes it easy to do the partial differentiation with respect
to $\mm$ necessary for the EM algorithm and as a result, easy to impose linear constraints and structure on the elements in a parameter matrix.
See \href{http://cran.r-project.org/web/packages/MARSS/vignettes/EMDerivation.pdf}{Holmes (2012)} for a discussion of the general form of MARSS models being fit by the EM algorithm in the MARSS package.

\section*{Need more information?}
The MARSS User Guide starts with some tutorials on MARSS models and walks through a bunch of simple examples so you get used to framing multivariate time-series models in matrix form.  Then it has a series of vignettes: how to write AR(p) models in state-space form, dynamic linear models (regression models where the regression parameters are AR(p)), multivariate regression models with regression parameters that are time-varying and enter the non-AR part of your model or the AR part, detecting breakpoints using state-space models, and dynamic factor analysis.  All of these can be written in MARSS form.  It also has a series of case studies of analyzing multivariate biological data.

<<Reset, echo=FALSE>>=
options(prompt="> ", continue="+ ")
@
\end{document}
