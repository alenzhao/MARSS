%\VignetteIndexEntry{Quick Start Guide}
%\VignettePackage{MARSS}
\documentclass[12pt]{article}
\usepackage{amsmath} % the standard math package
\usepackage[landscape]{geometry}
%%%% bold maths symbol system:
\def\uupsilon{\pmb{\upsilon}}
\def\llambda{\pmb{\lambda}}
\def\bbeta{\pmb{\beta}}
\def\aalpha{\pmb{\alpha}}
\def\zzeta{\pmb{\zeta}}
\def\etaeta{\mbox{\boldmath $\eta$}}
\def\xixi{\mbox{\boldmath $\xi$}}
\def\LAM{\mbox{\boldmath $\Lambda$}}
\def\GAM{\mbox{\boldmath $\Gamma$}}
\def\OMG{\mbox{\boldmath $\Omega$}}
\def\SI{\mbox{\boldmath $\Sigma$}}
\def\TH{\mbox{\boldmath $\Theta$}}
\def\UPS{\mbox{\boldmath $\Upsilon$}}
\def\XI{\mbox{\boldmath $\Xi$}}
\def\AA{\mbox{$\mathbf A$}}	\def\aa{\mbox{$\mathbf a$}} \def\Ab{\mbox{$\mathbf F$}} \def\Aa{\mbox{$\mathbf h$}} \def\Am{\PI}
\def\BB{\mbox{$\mathbf B$}}	\def\bb{\mbox{$\mathbf b$}} \def\Bb{\mbox{$\mathbf J$}} \def\Ba{\mbox{$\mathbf L$}} \def\Bm{\UPS}
\def\CC{\mbox{$\mathbf C$}}	\def\cc{\mbox{$\mathbf c$}}
\def\Ca{\Delta} \def\Cb{\GAM}
\def\DD{\mbox{$\mathbf D$}}	\def\dd{\mbox{$\mathbf d$}}
\def\EE{\mbox{$\mathbf E$}}	\def\ee{\mbox{$\mathbf e$}}
\def\E{\,\textup{\textrm{E}}}	
\def\EXy{\,\textup{\textrm{E}}_{\text{{\bf XY}}}}
\def\FF{\mbox{$\mathbf F$}} \def\ff{\mbox{$\mathbf f$}}
\def\GG{\mbox{$\mathbf G$}}	\def\gg{\mbox{$\mathbf g$}}
\def\HH{\mbox{$\mathbf H$}}	\def\hh{\mbox{$\mathbf h$}}
\def\II{\mbox{$\mathbf I$}}
\def\IIm{\mbox{$\mathbf I$}}
\def\JJ{\mbox{$\mathbf J$}}
\def\KK{\mbox{$\mathbf K$}}
\def\LL{\mbox{$\mathbf L$}}	\def\ll{\mbox{$\mathbf l$}}
\def\MM{\mbox{$\mathbf M$}}  \def\mm{\mbox{$\mathbf m$}}
\def\N{\,\textup{\textrm{N}}}
\def\MVN{\,\textup{\textrm{MVN}}}
\def\OO{\mbox{$\mathbf O$}}
\def\PP{\mbox{$\mathbf P$}}  \def\pp{\mbox{$\mathbf p$}}
\def\QQ{\mbox{$\mathbf Q$}}	 \def\qq{\mbox{$\mathbf q$}} \def\Qb{\mbox{$\mathbf G$}}  \def\RR{\mbox{$\mathbf R$}}	 \def\rr{\mbox{$\mathbf r$}} \def\Rb{\mbox{$\mathbf H$}}	\def\SS{\mbox{$\mathbf S$}}
\def\UU{\mbox{$\mathbf U$}}	\def\uu{\mbox{$\mathbf u$}} \def\Ub{\mbox{$\mathbf C$}} \def\Ua{\mbox{$\mathbf g$}} \def\Um{\UPS}
\def\VV{\mbox{$\mathbf V$}}	\def\vv{\mbox{$\mathbf v$}}
\def\WW{\mbox{$\mathbf W$}}	\def\ww{\mbox{$\mathbf w$}}
\def\XX{\mbox{$\pmb{X}$}}	\def\xx{\mbox{$\pmb{x}$}}
\def\YY{\mbox{$\pmb{Y}$}}	\def\yy{\mbox{$\pmb{y}$}}
\def\ZZ{\mbox{$\mathbf Z$}}	\def\zz{\mbox{$\mathbf z$}}	\def\Zb{\mbox{$\mathbf M$}} 
\def\vec{\,\textup{\textrm{vec}}}

\title{Quick Start Guide}
\begin{document}
<<RUNFIRST, echo=FALSE>>=
options(prompt=" ", continue=" ")
@
\section*{MARSS Quick Start Guide}
A MARSS model is a linear multivariate autoregressive state-space model, also called dynamic linear models (DLMs) or variable autoregressive (VAR) state-space models.  The default MARSS model used in the MARSS model (\verb@form="marxss"@) is written as follows (using $m=2$ and $n=3$):
\begin{gather*}
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_t
= \begin{bmatrix}b_{11}&b_{12}\\b_{21}&b_{22}\end{bmatrix}_t
\begin{bmatrix}x_1\\x_2\end{bmatrix}_{t-1}
+ \begin{bmatrix}c_{11}&c_{12}&c_{13}\\c_{21}&c_{22}&c_{23}\end{bmatrix}_t
\begin{bmatrix}c_1\\c_2\\c_3\end{bmatrix}_t + \begin{bmatrix}w_1\\ w_2\end{bmatrix}_t,\quad 
\begin{bmatrix}w_1\\ w_2\end{bmatrix}_t \sim MVN\begin{pmatrix}\begin{bmatrix}u_1\\u_2\end{bmatrix}_t,\begin{bmatrix}q_{11}&q_{12}\\q_{21}&q_{22}\end{bmatrix}_t \end{pmatrix}  \\
\\
\begin{bmatrix}y_1\\ y_2\\ y_3\end{bmatrix}_t
= \begin{bmatrix}z_{11}&z_{12}\\ z_{21}&z_{22}\\ z_{31}&z_{32}\end{bmatrix}_t
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_t
+ \begin{bmatrix}d_{11}&d_{12}\\d_{21}&d_{22}\\d_{31}&d_{32}\end{bmatrix}_t
\begin{bmatrix}d_1\\d_2\end{bmatrix}_t + \begin{bmatrix}v_1\\ v_2\\ v_3\end{bmatrix}_t,\quad 
\begin{bmatrix}v_1\\ v_2\\ v_3\end{bmatrix}_t \sim MVN\begin{pmatrix}\begin{bmatrix}a_1\\ a_2\\ a_3\end{bmatrix}_t,
 \begin{bmatrix}r_{11}&r_{12}&r_{13}\\r_{21}&r_{22}&r_{23}\\r_{31}&r_{32}&r_{33}\end{bmatrix}_t \end{pmatrix}  \\
\\
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_0 \sim MVN\begin{pmatrix}\begin{bmatrix}\pi_1\\ \pi_2\end{bmatrix},\begin{bmatrix}\nu_{11}&\nu_{12}\\ \nu_{21}&\nu_{22}\end{bmatrix} \end{pmatrix} \quad 
or\quad 
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_1 \sim MVN\begin{pmatrix}\begin{bmatrix}\pi_1\\ \pi_2\end{bmatrix},\begin{bmatrix}\nu_{11}&\nu_{12}\\ \nu_{21}&\nu_{22}\end{bmatrix} \end{pmatrix} 
\end{gather*} 
$\cc$ and $\dd$ are inputs (aka, exogenous variables or covariates or indicator variables) and should have no missing values.  They are not treated as `data' in the likelihood but as inputs. 

First write your model in the form above.  Many of the parameter elements will be fixed or zero and others will be shared (equal) within a matrix.  The following shows an example of a mean-reverting random walk model with three observation time series:
\begin{gather*}
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_t
= \begin{bmatrix}b&0\\ 0&b\end{bmatrix}
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_{t-1}
+ \begin{bmatrix}w_1\\ w_2\end{bmatrix}_t, \quad 
\begin{bmatrix}w_1\\ w_2\end{bmatrix}_t \sim MVN\begin{pmatrix}\begin{bmatrix}0\\0\end{bmatrix},\begin{bmatrix}q_{11}&q_{12}\\ q_{12}&q_{22}\end{bmatrix} \end{pmatrix}, \quad
\begin{bmatrix}x_1\\ x_2\end{bmatrix}_0 \sim MVN\begin{pmatrix}\begin{bmatrix}0\\ 0\end{bmatrix},\begin{bmatrix}1&0\\ 0&1\end{bmatrix} \end{pmatrix} \\
\\
\begin{bmatrix}y_1\\y_2\\y_3\end{bmatrix}_t
= \begin{bmatrix}1&1\\ 0&1\\ 1&0\end{bmatrix}
\begin{bmatrix}x_1\\x_2\end{bmatrix}_t
+ \begin{bmatrix}v_1\\ v_2\\ v_3\end{bmatrix}_t,\quad 
\begin{bmatrix}v_1\\ v_2\\ v_3\end{bmatrix}_t \sim MVN\begin{pmatrix}\begin{bmatrix}a_1\\ 0\\ 0\end{bmatrix},
 \begin{bmatrix}r_{11}&0&0\\ 0&r&0\\ 0&0&r\end{bmatrix} \end{pmatrix} 
\end{gather*}

The model specification for the MARSS package has a one-to-one relationship to the model written on paper, i.e. you specify the form of the parameter matrices using matrices in R.  Matrices that combine fixed and estimated values are specified using a list matrix with numerical values for fixed values and  character names for the estimated values. The following shows how to specify the model above.
<<model.spec, eval=FALSE>>=
B1=matrix(list("b",0,0,"b"),2,2)
U1=matrix(0,2,1)
Q1=matrix(c("q11","q12","q12","q22"),2,2)
Z1=matrix(c(1,0,1,1,1,0),3,2)
A1=matrix(list("a1",0,0),3,1)
R1=matrix(list("r11",0,0,0,"r",0,0,0,"r"),3,3)
pi1=matrix(0,2,1); V1=diag(1,2)
model.list=list(B=B1,U=U1,Q=Q1,Z=Z1,A=A1,R=R1,x0=pi1,V0=V1,tinitx=0)
@
For \verb@form="marxss"@ (the default), matrix names in the model list must be B, U, C, c, Q, Z, A, D, d, R, x0, and V0.  The tinitx element tells MARSS whether the initial state for x is at $t=1$ (\verb@tinitx=1@) or $t=0$ (\verb@tinitx=0@).   The data must be entered as a $n \times T$ matrix; a dataframe is not a matrix nor is a vector.  There are many text shortcuts for common parameter forms, such as ``diagonal and unequal''; see the User Guide for the possible shortcuts. You can leave off matrix names and the defaults will be used. Type ?MARSS.marxss to see the defaults for \verb@form="marxss"@.

The call to MARSS then becomes (type \verb@?MARSS@ at the command line for more info).
<<marss.call, eval=FALSE>>=
fit=MARSS(data, model=model.list)
@

The R, Q and V0 variances can be set to zero to specify partially deterministic systems.  This allows you to write MAR-p models in MARSS form for example. See the User Guide for examples.

 \textit{Specification of a properly constrained model with a unique solution is the responsibility of the user because MARSS has no way to tell if you have specified an insufficiently constrained model.}

\pagebreak
\section*{Time-varying parameters and inputs}
The default model form (\verb@form="marxss"@) allows you to pass in an array of $T$ matrices for a time-varying parameter ($T$ is the number of time-steps in your data):  
%\begin{equation}\label{qeq:MARSS.ex.vec}
\begin{equation}\label{qeq:MARSS.tv}
\begin{gathered}
\xx_t = \BB_t\xx_{t-1} + \uu_t + \CC_t\cc_t + \ww_t, \quad
\WW_t \sim \MVN(0,\QQ_t)\\
\yy_t = \ZZ_t\xx_t + \aa_t + \DD_t\dd_t + \vv_t, \quad
\VV_t \sim \MVN(0,\RR_t)\\
\xx_{t_0} \sim \MVN(\xixi,\LAM)
\end{gathered}
\end{equation}
Zeros are allowed on the diagonals of $\QQ$, $\RR$ and $\LAM$.

The length of the 3rd dimension must be the same as your data.  For example, say in your  mean-reverting random walk model (the example on the first page) you wanted $\BB(2,2)$ to be one value before $t=20$ and another value after but $\BB(1,1)$ to be time constant. You can pass in the following:
<<model.spec2, eval=FALSE>>=
TT=dim(data)[2]
B1=array(list(),dim=c(2,2,TT))
B1[,,1:20]=matrix(list("b",0,0,"b_1"),2,2)
B1[,,21:TT]=   matrix(list("b",0,0,"b_2"),2,2)
@
Notice the specification is one-to-one to how you would write your $\BB_t$ matrices on paper.

Inputs are specified in exactly the same manner.  $\CC$ and $\DD$ are the estimated parameters and $\cc$ and $\dd$ are the inputs.  Let's say you have temperature data and you want to include a linear effect of temperature that is different for each $\xx$ time series:
<<model.spec, eval=FALSE>>=
C1=matrix(c("temp1","temp2"),2,1)
model.list=list(B=B1,U=U1,C=C1,c=temp,Q=Q1,Z=Z1,A=A1,R=R1,x0=pi1,V0=V1,tinitx=0)
@
If you want a factor effect, then you'll need to recode your factor as a matrix with TT columns and a row for each factor.  Then you have 0 or 1 if that factor applies in time period $t$.  $\CC$ then has a column for each estimated factor effect.

\section*{Printing output}
There are print and summary functions for marssMLE and marssm objects.  marssMLE objects are what is output by a call to \verb@MARSS()@.  A marssm object is the model object in MARSS.  A \verb@print@ call can also print other useful output such as the parameters, the estimated states, state standard errors, etc.  Type \verb@?print.MARSS@ to see the various output that can be printed from a \verb@print@ call.
 
\section*{The full time-varying model used in the MARSS EM algorithm}
Expectation-Maximization algorithms for unconstrained MARSS models have been around for many years.  What makes the EM algorithm in MARSS different is that it is a constrained algorithm.  In mathematical form, the MARSS model with linear constraints that is being fit with the package is
\begin{equation}\label{qeq:MARSS.ex.vec}
\begin{gathered}
\xx_t = (\xx_{t-1}^\top \otimes \II_m)\vec(\BB_t) + (\uu_t^\top \otimes \II_m)\vec(\UU_t) + \ww_t, \quad
\WW_t \sim \MVN(0,\QQ_t)\\
\yy_t = (\xx_t^\top \otimes \II_n)\vec(\ZZ_t) + (\aa_t^\top \otimes \II_n)\vec(\AA_t) + \vv_t, \quad
\VV_t \sim \MVN(0,\RR_t)\\
\xx_{t_0} = \xixi+\FF\ll, 
\LL \sim \MVN(0,\LAM)
\end{gathered}
\end{equation}

Each model parameter matrix, $\BB_t$, $\UU_t$, $\QQ_t$, $\ZZ_t$, $\AA_t$, and $\RR_t$, is written as a time-varying linear model, $\ff_t+\DD_t\mm$, where $\ff$ and $\DD$ are fully-known (not estimated and no missing values) and $\mm$ is a column vector of the estimates elements of the parameter matrix:
\begin{gather*}
\vec(\BB_t) = \ff_{t,b} + \DD_{t,b}\bbeta\quad
\vec(\UU_t) = \ff_{t,u} + \DD_{t,u}\uupsilon\quad
\vec(\QQ_t) = \ff_{t,q} + \DD_{t,q}\qq\\
\vec(\ZZ_t) = \ff_{t,z} + \DD_{t,z}\zzeta\quad
\vec(\AA_t) = \ff_{t,a} + \DD_{t,a}\aalpha\quad
\vec(\RR_t) = \ff_{t,r} + \DD_{t,r}\rr\\
\vec(\LAM)= \ff_\lambda+\DD_\lambda\llambda \quad
\vec(\xixi)= \ff_\xi+\DD_\xi\pp
\end{gather*}

The internal MARSS model specification (marssm objects) is just a list with the $\ff_t$ and $\DD_t$ matrices for each parameter.   The output from fitting are the vectors, $\bbeta$, $\uupsilon$, etc.  The trick is to rewrite the user's linear multivariate problem into the general form (equation \ref{qeq:MARSS.ex.vec}).  MARSS does this using functions that take more familiar arguments as input and then constructs the $\ff_t$ and $\DD_t$ matrices.  Because the $\ff_t$ and $\DD_t$ can be whatever the user wants (assuming they are the right shape), this allows users to include covariates, trends (linear, sinusoidal, etc) or indicator variables in a variety of ways.
<<Reset, echo=FALSE>>=
options(prompt="> ", continue="+ ")
@
\end{document}
