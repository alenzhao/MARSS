\chapter{Overview of the package functions}
\label{chap:mainfunctions}
The MARSS package is object-based.  It has two main types of objects: a model object (class marssm)\index{objects!marssm} and a maximum-likelihood fitted model object (class marssMLE)\index{objects!marssMLE}. A marssm object specifies the structure of the model to be fitted.  It is an \R code version of the MARSS equation (Equation \ref{eqn:marss}).  A marssMLE object specifies both the model and the information necessary for fitting (initial conditions, controls, method).  If the model has been fitted, the marssMLE object will also have the parameter estimates and (optionally) confidence intervals and bias.  

\section{The \texttt{MARSS()} function}
The function \verb@MARSS()@ is an interface to the core fitting functions in the MARSS package.  It allows a user to fit a MARSS model using simple text strings to describe the model structure.  It returns marssm and marssMLE objects which the user can later use in other functions, e.g. simulating or computing bootstrap confidence intervals.
\begin{description}
	\item[\texttt{MLEobj=MARSS(data, constraint=list(), ..., fit=TRUE)}]\index{functions!MARSS} This function will fit a MARSS model to the data using a constraint list which is a list of strings describing the structure of the model parameter matrices.  The default model has a one-to-one correspondence between the state processes and observation time series ($\ZZ$ is the identity matrix).  The default has a diagonal observation error matrix ($\RR$) and an unconstrained process-error matrix ($\QQ$).  The output is a marssMLE object where the estimated parameter matrices are in \verb@MLEobj$par@.  If \verb@fit=FALSE@, it returns a minimal marssMLE object that is ready for passing to a fitting function (below) but with no \verb@par@ element.
\end{description}

\section{Core functions for fitting a MARSS model}
The following core functions are designed to work with `unfitted' marssMLE objects, that is a marssMLE object without the \verb@par@ element.  Users do not normally need to call the \verb@MARSSkem@ or \verb@MARSSoptim@ functions since \verb@MARSS()@ will call those. Below \verb@MLEobj@ means the argument is a marssMLE object.  Note, these functions can be called with a marssMLE object with a \verb@par@ element, but these functions will overwrite that element.

\begin{description}
	\item[\texttt{MLEobj=MARSSkem(MLEobj)}]\index{functions!MARSSkem (EM algorithm)}\index{estimation!Kalman-EM} This will fit a MARSS model via the Kalman-EM algorithm to the data using a properly specified marssMLE object, which has data, the marssm object and the necessary initial condition and control elements.  See the appendix on the object structures in the MARSS package.  \texttt{MARSSkem}	does no error-checking.  See \texttt{is.marssMLE()}. \verb@MARSSkem@ uses \verb@MARSSkf@ described below.  
	\item[\texttt{MLEobj=MARSSoptim(MLEobj)}]\index{functions!MARSSoptim (quasi-Newton)}\index{estimation!quasi-Newton} This will fit a MARSS model via the BFGS algorithm provided in \verb@optim()@\index{functions!optim}. This requires a properly specified marssMLE object, such as would be passed to \verb@MARSSkem@. 
	\item[\texttt{MLEobj=MARSSmcinit(MLEobj)}]\index{functions!MARSSmcinit} This will perform a Monte Carlo initial conditions search and update the marssMLE object with the best initial conditions from the search.
	\item[\texttt{is.marssMLE(MLEobj)}]\index{functions!is.marssMLE} This will check that a marssMLE object is properly specified and ready for fitting.  This should be called before \texttt{MARSSkem} or \texttt{MARSSoptim} is called.  This function is not typically needed if using \texttt{MARSS()} since \texttt{MARSS()} builds the model object for the user and does error-checking on model structure.
\end{description}

\section{Functions for a fitted marssMLE object}
The following functions use a marssMLE object that has a populated \verb@par@ element, i.e. a marssMLE object returned from one of the fitting functions (\verb@MARSS@, \verb@MARSSkem@, \verb@MARSSoptim@).  Below \verb@modelObj@ means the argument is a marssm object and \verb@MLEobj@ means the argument is a marssMLE object.  Type \verb@?function.name@ to see information on function usage and examples.
\begin{description}
	\item[\texttt{kf=MARSSkf(data, parList, ...)}]\index{functions!MARSSkf (Kalman filter)}\index{likelihood}\index{estimation!Kalman filter}\index{estimation!Kalman smoother} This will compute the expected values of the hidden states given data via the Kalman filter (to produce estimates conditioned on $1:t-1$) and the Kalman smoother (to produce estimates conditioned on $1:T$).  The function also returns the exact likelihood of the data conditioned on \verb@parList@. A variety of other Kalman filter/smoother information is also output (\verb@kf@ is a list of output); see \verb@?MARSSkf@ for more details.
	\item[\texttt{MLEobj=MARSSaic(MLEobj)}]\index{functions!MARSSaic}\index{model selection!MARSSaic function}  This adds model selection criteria, AIC, AICc, and AICb, to a marssMLE object.
	\item[\texttt{boot=MARSSboot(MLEobj)}]\index{functions!MARSSboot}\index{bootstrap!MARSSboot function} This returns a list containing bootstrapped parameters and data via parametric\index{bootstrap!parametric} or innovations\index{bootstrap!innovations} bootstrapping.
	\item[\texttt{MLEobj=MARSShessian(MLEobj)}]\index{functions!MARSShessian}\index{confidence intervals!Hessian approximation} This adds a numerically estimated Hessian matrix to a marssMLE object.
	\item[\texttt{MLEobj=MARSSparamCIs(MLEobj)}]\index{functions!MARSSparamCIs}\index{confidence intervals!parametric bootstrap}\index{confidence intervals!non-parametric bootstrap}\index{confidence intervals!MARSSparamCIs function}\index{standard errors} This adds standard errors, confidence intervals, and bootstrap estimated bias for the maximum-likelihood parameters using bootstrapping or the Hessian to the passed in marssMLE object.
\item[\texttt{sim.data=MARSSsimulate(parList)}]\index{functions!MARSSsimulate}\index{simulation!MARSSsimulate function} This returns simulated data from a MARSS model specified via a list of parameter matrices in \verb@parList@ (this is a list with elements \texttt{Q}, \texttt{R}, \texttt{U}, etc).  Typically one would pass in \verb@parList@ using the \verb@par@ element in an marssMLE object (i.e., \verb@MLEobj$par@), but you could also construct the list manually.
\item[\texttt{paramVec=MARSSvectorizeparam(MLEobj)}]\index{functions!MARSSvectorizeparam} This returns the estimated (and only the estimated) parameters as a vector.  This is useful for storing the results of simulations and for writing functions that fit MARSS models using R's \texttt{optim} function.
\item[\texttt{new.MLEobj=MARSSvectorizeparam(MLEobj, paramVec)}] This will return a marssMLE object in which the estimated parameters (which are in \verb@MLEobj$par@ along with the fixed values) are replaced with the values in \texttt{paramVec}.
\end{description}

\section{Functions for marssm objects}
\index{objects!marssm}\begin{description}	
		\item[\texttt{is.marssm(modelObj)}]\index{functions!is.marssm} This will check that the free and fixed matrices in a marssm object are properly specified.  This function is not typically needed if using \texttt{MARSS()} since \texttt{MARSS()} builds the marssm object for the user and does error-checking on model structure.
		\item[\texttt{summary(modelObj)}]\index{functions!summary} This will print the model parameter matrices showing the fixed values (in parentheses) and the location of the estimated elements.  The estimated elements are shown as g1, g2, g3, ... which indicates which elements are shared (i.e., forced to have the same value).  For example, an i.i.d. $\RR$ matrix would appear as a diagonal matrix with just g1 on the diagonal.
\end{description}
