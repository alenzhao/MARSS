\chapter{The MARSS() function}\label{chap:MARSS}

The \verb@MARSS()@ function is an interface to the core functions and allows users to fit MARSS models using text strings to specify the model structure.  The MARSS model takes the form
\begin{subequations}\label{eqn:mgompertz}
\begin{gather}
	\xx_t = \BB \xx_{t-1} + \uu + \ee_{t-1}, \text{ where } \ee_{t-1} \sim \MVN(0,\QQ)\label{eqn:mgompertzX}\\
	\yy_t = \ZZ \xx_t + \aa + \et_t, \text{ where } \et_t \sim \MVN(0,\RR)\label{eqn:mgompertzY}\\
	\xx_1 \sim \MVN(\pipi,\VV_1) \label{eqn:mgompertzX1}
\end{gather}
\end{subequations}
The $\yy$ is a $n \times T$ matrix of observations and the $\xx$ is a $m \times T$ matrix of hidden states.  For example, a $\yy$ data matrix of 3 inputs ($n=3$) measured for 10 time steps would look like
\begin{equation*}
\yy = \left[ \begin{array}{ccccccc}
    1 & 2 & -99 & -99 & 3.2 & ... &8\\
    2 & 5 &  3 & -99 & 5.1 & ... &5\\
    1 &-99 & 2 & 2.2 & -99 & ... &7\end{array} \right]
\end{equation*}
where -99 denotes a missing value.  $\xx$ might look like (here $m=2$):
\begin{equation*}
\xx = \left[ \begin{array}{ccccccc}
    0.8 & 2.2 & 3 & 2.8 & 3.2 & ... &7.1\\
    1.5 & 2.5 & 2.5 & 2.2 & 3.1 & ... &6\end{array} \right]
\end{equation*}
 $\ZZ$ is a $n \times m$ design matrix of zeros and ones where the row sums equal one\footnote{In our examples, $\ZZ$ is a design matrix but it can actually be any fixed matrix.}.  $\ZZ$ specifies which observation time series, $y_{i,1:T}$, is associated with which hidden state process, $x_{j,1:T}$.  $\ZZ$ is like a look up table with one row for each of the $n$ observation time series and one column for each of the $m$ hidden processes.  A ``1'' in row $i$ column $j$ means that $\yy$ time series $i$ is measuring the $j$-th $\xx$ trajectory.  Otherwise the value in $\ZZ_{ij}=0$.

In the \verb@MARSS()@ function, the user specifies the model by passing in a parameter constraint list:\index{model specification!in MARSS}
\begin{Schunk}
\begin{Sinput}
MARSS(data, constraint=list(Z=Z.constraint, B=B.constraint, 
       U=U.constraint, Q=Q.constraint, A=A.constraint, 
       R=R.constraint, x0=pi.constraint, V0=V1.constraint) ) 
\end{Sinput}
\end{Schunk}
\verb@data@ must be a $n \times T$ matrix, that is time goes across columns.   The argument \verb@constraint@ is a list of text strings, factors or a matrix that specifies the form of the MARSS parameters.  The defaults are
\begin{itemize}
\item[] \verb@Z.constraint="identity"@ each $y$ in $\yy$ corresponds to one $x$ in $\xx$
\item[] \verb@B.constraint="identity"@ no interactions between the $x$'s in $\xx$
\item[] \verb@U.constraint="unequal"@ the $u$'s in $\uu$ are all different
\item[] \verb@Q.constraint="diagonal and unequal"@ process errors are independent but have different variances
\item[] \verb@R.constraint="diagonal and equal"@ the observations are i.i.d.
\item[] \verb@A.constraint="scaling"@ $\aa$ is a set of scaling factors
\item[] \verb@pi.constraint="unequal"@ all initial states are different
\item[] \verb@V0.constraint="zero"@ the initial condition $\xx_1$ is fixed but unknown
\end{itemize}
The other possible \verb@constraint@ options for each parameter are listed below.  We show the forms using $m=3$ (the number of hidden state processes) as an example.

\section{Process equation constraints}

\subsection{\texttt{B.constraint}}

$\BB$ is a $m \times m$ matrix.  In MARSS 1.0, $\BB$ must be fixed.  
\begin{itemize}\itemsep5pt
\item[] \texttt{B.constraint="identity"} The $\BB$ matrix is the identity matrix:
\begin{equation*}
 \left[ \begin{array}{ccc}
    1 & 0 & 0\\
    0 & 1 & 0 \\
    0 & 0 & 1 \end{array} \right]
\end{equation*}
\item[] \texttt{B.constraint=matrix(..., nrow=m, ncol=m)}  Passing in a $m \times m$ matrix, means that $\BB$ is fixed to the values in the matrix. The matrix must be numeric and all eigenvalues must fall within the unit circle\footnote{meaning \texttt{all(abs(eigen(B)\$values)>=1)}.}.  Using the string ``zero'', sets $\BB=0$.
\end{itemize}

\subsection{$\uu$ constraints}

The $\uu$ constraint has the following options:
\begin{itemize}\itemsep5pt
\item[] \texttt{U.constraint="equal"} There is only one value in $\uu$:
\begin{equation*}
 \left[ \begin{array}{c}
    u \\
    u \\
    u \end{array} \right]
\end{equation*}

\item[] \texttt{U.constraint="unequal"} or \texttt{U.constraint="unconstrained"} There are $m$ values in $\uu$: 
\begin{equation*}
 \left[ \begin{array}{c}
    u_1\\
    u_2\\
    u_3 \end{array} \right]
\end{equation*}

\item[] \texttt{U.constraint=as.factor(c(...))} Here the constraint is specified as a length $m$ character or numeric vector of class factor.  The vector of factors specifies which values in $\uu$ are shared.  \texttt{U.constraint=factor(c(1,1,2))} means that $\uu$ has the following structure:
\begin{equation*}
 \left[ \begin{array}{c}
    u_1 \\
    u_1 \\
    u_2 \end{array} \right]
\end{equation*}
There are two values in $\uu$ in this case.  The factor levels can be either numeric or character.  \verb@c(1,1,2)@ is the same as \verb@c("north","north","south")@.

\item[] \texttt{U.constraint=matrix(..., nrow=m, ncol=1)} Passing in a $m \times 1$ matrix, means that $\uu$ is fixed to the values in the matrix. The matrix must be numeric.  In MARSS 1.0, $\uu$ cannot vary in time, even if fixed.  $\uu$ can be set to all zeros (a $m \times 1$ matrix) by setting \texttt{U.constraint="zero"}; you might want to use this if you de-trended your data.  

\item[] You can also pass in a matrix with fixed values and NAs: 
\begin{equation*}
 \left[ \begin{array}{c}
    0.1 \\
    NA \\
    NA \end{array} \right]
\end{equation*}
The fixed values will be set to the fixed values and the elements specified by NAs will be estimated.  The estimated elements are independent and not forced to be equal.

\end{itemize}

\subsection{$\QQ$ constraint}

The $\QQ$ constraint has the following options:
\begin{itemize}\itemsep5pt
\item[] \texttt{Q.constraint="diagonal and equal"} There is only one process variance value in this case:
\begin{equation*}
 \left[ \begin{array}{ccc}
    \sigma^2 & 0 & 0\\
    0 & \sigma^2 & 0 \\
    0 & 0 & \sigma^2 \end{array} \right]
\end{equation*}

\item[] \texttt{Q.constraint="diagonal and unequal"}  There are $m$ process variance values in this case:  
\begin{equation*}
 \left[ \begin{array}{ccc}
    \sigma^2_1 & 0 & 0\\
    0 & \sigma^2_2 & 0 \\
    0 & 0 & \sigma^2_3 \end{array} \right]
\end{equation*}

\item[] \texttt{Q.constraint="unconstrained"} There are values on the diagonal and the off-diagonals of $\QQ$ and the variances and covariances are all different:  
\begin{equation*}
 \left[ \begin{array}{ccc}
    \sigma^2_1 & \sigma_{1,2} & \sigma_{1,3}\\
    \sigma_{1,2} & \sigma^2_2 & \sigma_{2,3} \\
    \sigma_{1,3} & \sigma_{2,3} & \sigma^2_3 \end{array} \right]
\end{equation*}
There are $m$ process variances and $(m^2-m)/2$ covariances in this case, so $(m^2+m)/2$ values to be estimated.
\item[] \texttt{Q.constraint="equalvarcov"} There is one process variance and one covariance:
\begin{equation*}
 \left[ \begin{array}{ccc}
    \sigma^2 & \beta & \beta\\
    \beta & \sigma^2 & \beta \\
    \beta & \beta & \sigma^2 \end{array} \right]
\end{equation*}
  
\item[] \texttt{Q.constraint=as.factor(c(...))} The constraint is specified as a length $m$ character or numeric vector of class factor.  This specifies that $\QQ$ is diagonal and the vector of factors specifies which values on the diagonal are shared.  For example, \texttt{Q.constraint=factor(c(2,1,2))} means that $\QQ$ takes the form:
\begin{equation*}
 \left[ \begin{array}{ccc}
    \sigma^2_2 & 0 & 0\\
    0 & \sigma^2_1 & 0 \\
    0 & 0 & \sigma^2_2 \end{array} \right]
\end{equation*}
 \texttt{Q.constraint=factor(c(1,1,2))} means that $\QQ$ takes the form:
\begin{equation*}
 \left[ \begin{array}{ccc}
    \sigma^2_1 & 0 & 0\\
    0 & \sigma^2_1 & 0 \\
    0 & 0 & \sigma^2_2 \end{array} \right]
\end{equation*}
The factor levels can be either numeric or character.  \verb@c(1,1,2)@ is the same as \verb@c("north","north","south")@.  

\item[] \texttt{Q.constraint=matrix(..., nrow=m, ncol=m)}  Passing in a $m \times m$ matrix, means that $\QQ$ is fixed to the values in the matrix. The matrix must be numeric.  Note if $m=1$, you still need to wrap its value in \verb@matrix()@ so that its class is matrix.  

\item[] You can also pass in a diagonal matrix with fixed values and NAs: 
\begin{equation*}
 \left[ \begin{array}{ccc}
    NA & 0 & 0\\
    0 & 0.1 & 0 \\
    0 & 0 & NA \end{array} \right]
\end{equation*}
The fixed values will be set to the fixed values and the NAs will be estimated; the estimates are independent and not forced to be equal. The matrix must be diagonal (0s on the off-diagonals).

\end{itemize}

\subsection{$\pipi$ constraints}

This sets the constraints on the initial conditions, $\xx_1$.  \verb@pi.constraint@ has the following options:
\begin{itemize}\itemsep5pt
\item[] \texttt{pi.constraint="equal" } There is only initial state value.
\begin{equation*}
 \left[ \begin{array}{c}
    \pi \\
    \pi \\
    \pi \end{array} \right]
\end{equation*}
Warning: specifying shared values in $\pipi$ will tend to produce ill-conditioned matrices in the algorithm and lead to numerical instability.  Avoid using \verb@pi.constraint="equal"@ if possible.

\item[] \texttt{pi.constraint="unequal"} or \texttt{pi.constraint="unconstrained"} These are equivalent.  There are $m$ initial state parameters.  
\begin{equation*}
 \left[ \begin{array}{c}
    \pi_1\\
    \pi_2\\
    \pi_3 \end{array} \right]
\end{equation*}

\item[] \texttt{pi.constraint=factor(c(...))} The constraint is specified is a length $m$ character or numeric vector of class factor.  The vector of factors specifies which initial states have the same value.  For example, \texttt{pi.constraint=factor(c(1,1,2))} means that $\pipi$ takes the form:
\begin{equation*}
 \left[ \begin{array}{c}
    \pi_1 \\
    \pi_1 \\
    \pi_2 \end{array} \right]
\end{equation*}
There are two initial state parameters in this case.  The factor levels can be either numeric or character.  \verb@c(1,1,2)@ is the same as \verb@c("n","n","s")@.
Warning: specifying shared values in $\pipi$ will tend to produce ill-conditioned matrices in the algorithm and lead to numerical instability.  Avoid if possible.

\item[] \texttt{pi.constraint=matrix(..., nrow=m, ncol=1)}  Passing in a $m \times 1$ matrix, means that the initial states are fixed to the values in the matrix. The matrix must be numeric.  You can set the initial states to zero by using \texttt{pi.constraint="zero"}. 

\item[] You can also pass in a matrix with fixed values and NAs: 
\begin{equation*}
 \left[ \begin{array}{c}
    10 \\
    NA \\
    NA \end{array} \right]
\end{equation*}
The fixed values will be set to the fixed values and the values specified by NAs will be estimated.

\end{itemize}

\subsection{$\VV_1$ constraints}

The initial state variance must be fixed.  The default behavior is to treat $\xx_1$ as fixed but unknown\footnote{Shumway and Stoffer use $\xx$ at $t=0$ as the initial state, but we follow Ghahramani's approach and use $\xx$ at $t=1$ as the initial state. Both approaches give the same answer but the EM update equations are slightly different.}.  In this case, $\VV_1$=0.  You can also set $\VV_1$ to a non-zero value but in that case $\pipi$ must be fixed.  This would translate to using fixed prior for the initial states.
 \begin{itemize}\itemsep5pt
 \item[] \texttt{V0.constraint=matrix(..., nrow=m, ncol=m)}  Passing in a $m \times m$ matrix, means that the initial state variance is fixed to the values in the matrix. The matrix must be numeric and be a proper variance-covariance matrix.
 \end{itemize}
In general, unless a fixed prior is desired, users should just leave off \verb@x0.constraint@ and \verb@V0.constraint@ from the constraint list and use the default behavior which is $\xx_1$ treated as fixed but unknown.

\section{Observation equation constraints}

\subsection{$\ZZ$ constraint}
In the \verb@MARSS()@ function, $\ZZ$ is normally a $n \times m$ design matrix that specifies which $x_i$ hidden state time series corresponds to which $y_j$ time series\footnote{However, you can pass in other fixed but non-design $\ZZ$ matrices.}.  In this case, each $y_j$ time series (each row in $\yy$) corresponds to one and only one $x_i$ time series (row in $\xx$).  The $\ZZ$ constraint is normally specified as a length $n$ vector of class factor. The $i$-th element of this vector specifies which row in $\xx$ that the $i$-th row in $\yy$ corresponds to.   Below are some examples of $\ZZ$ matrices; see Chapter \ref{Examples} and the case studies chapters for more examples.
\begin{itemize}\itemsep5pt
\item[] \texttt{Z.constraint=factor(c(1,1,1))}  All $\yy$ time series are observing the same (and only) hidden state trajectory $x$ ($n=3$ and $m=1$):
\begin{equation*}
 \ZZ =
 \left[ \begin{array}{c}
    1  \\
    1  \\
    1  
    \end{array} \right]  
\end{equation*}

\item[] \texttt{Z.constraint=factor(c(1,2,3))}  Each time series in $\yy$ corresponds to a different hidden state trajectory.  This is the default $\ZZ$ constraint and in this case $n=m$:
\begin{equation*}
 \ZZ =
  \left[ \begin{array}{ccc}
    1 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1 \end{array} \right]
\end{equation*}

\item[] \texttt{Z.constraint=factor(c(1,1,2))} The first two time series in $\yy$ corresponds to one hidden state trajectory and the third $\yy$ time series corresponds to a different hidden state trajectory.  Here $n=3$ and $m=2$:
\begin{equation*}
 \ZZ =
  \left[ \begin{array}{cc}
    1 & 0  \\
    1 & 0  \\
    0 & 1  \end{array} \right]
\end{equation*}
The $\ZZ$ constraint can be specified using either numeric or character factor levels.  \verb@c(1,1,2)@ is the same as \verb@c("north","north","south")@

\item[] \texttt{Z.constraint="identity"} This is the default behavior.  This means $\ZZ$ is a $n \times n$ identity matrix and $m=n$.  If $n=3$, it is the same as \texttt{Z.constraint=factor(c(1,2,3))}.

\item[] \texttt{Z.constraint=matrix(..., nrow=n, ncol=m)}  Passing in a $n \times m$ matrix, means that $\ZZ$ is fixed to the values in the matrix. The matrix must be numeric but it does not need to be a design matrix.

\end{itemize}

\subsection{$\aa$ constraint}

Using the \verb@MARSS()@ function, only \verb@A.constraint="scaling"@ or a fixed $\aa$ are allowed.  If ``scaling'', $\aa$ is a scaling factor without any direct meaning (it just says how the time series in $\yy$ scale relative to each other).   Unless you know the correct scaling, because say you simulated the data or you de-meaned the data, you should use the default.   To set $\aa$ to a fixed value (not estimated), use \texttt{A.constraint=matrix(..., nrow=n, ncol=m)}. The matrix must be numeric.  To fix $\aa$ to zero, use \texttt{A.constraint="zero"}.  

Note, you can circumvent the restriction on $\aa$ by passing in a matrix with NAs (for estimated elements) or passing in a \verb@fixed@/\verb@free@ pair.  But be aware that it is very easy to make your model unsolvable (an infinite number of solutions)---if for example you try to estimate more that $n_i-1$ $a$'s, where $n_i$ is the number of $y$'s for one $x$.  If $\ZZ$ is identity, then $n_i=1$ and you can estimate no $a$'s; all must be fixed. 

\subsection{$\RR$ constraint}

The $\RR$ constraint is completely analogous to the $\QQ$ constraint, except that it is $n \times n$ instead of $m \times m$.  Its allowable constraints are affected by the presence of missing data points in $\yy$.  If data are missing, then $\RR$ must be diagonal.
