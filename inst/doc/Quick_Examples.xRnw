\SweaveOpts{keep.source=TRUE, prefix.string=./figures/QE-, eps=FALSE, split=FALSE}
\chapter{Examples}
\label{Examples}
\chaptermark{Examples}

<<RUNFIRST, echo=F, include.source=F>>=
require(MARSS)
options(prompt=" ", continue=" ", width=60)
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Here we show a series of short examples using the MARSS package functions.  Chapters \ref{chap:CSpva}--\ref{chap:CStracks} give case studies which walk through detailed multi-level analyses.  
The examples in this chapter use the Washington harbor seal dataset (\verb@?harborSealWA@), which has five observation time series. First set up the data to make time go across the columns and to remove the year column:
<<enterdata, include.source=F, keep.source=T>>=
dat = t(harborSealWA)
dat = dat[2:nrow(dat),] #remove the year row
@

\section{Fitting different MARSS models to a dataset}
\subsection{One hidden state process for each observation time series}
This is the default model for the \verb@MARSS()@ function.  In this case, $n=m$, the observation errors are i.i.d. and the process errors are independent and have different variances.  The elements in $\uu$ are all different (meaning, they are not forced to be the same).  Mathematically, the MARSS model being fit is:
\begin{gather*}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
= \begin{bmatrix}x_{1,t-1}\\x_{2,t-1}\\x_{3,t-1}\\x_{4,t-1}\\x_{5,t-1}\end{bmatrix}
+ \begin{bmatrix}u_1\\u_2\\u_3\\u_4\\u_5\end{bmatrix}
+ \begin{bmatrix}v_{1,t}\\v_{2,t}\\v_{3,t}\\v_{4,t}\\v_{5,t}\end{bmatrix},
 \textrm{ } \vv_t \sim \MVN\begin{pmatrix}0,\begin{bmatrix}q_1&0&0&0&0\\0&q_2&0&0&0\\0&0&q_3&0&0\\0&0&0&q_4&0\\0&0&0&0&q_5\end{bmatrix} \end{pmatrix}  \\
\\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1&0&0&0&0\\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1\end{bmatrix}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
+ \begin{bmatrix}0\\0\\0\\0\\0\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix},
 \textrm{ } \ww_t \sim \MVN\begin{pmatrix}0,\begin{bmatrix}r&0&0&0&0\\0&r&0&0&0\\0&0&r&0&0\\0&0&0&r&0\\0&0&0&0&r\end{bmatrix} \end{pmatrix}  \\
\end{gather*}
To fit this model, use \verb@MARSS()@\index{functions!MARSS}.  The function will output the basic model structure and the time to convergence.  Notice that the output warns you that the convergence tolerance is high.  You can set it lower by passing in \verb@control=list(conv.test.slope.tol=0.1)@.
<<model-default, include.source=FALSE, keep.source=TRUE>>=
kemfit = MARSS(dat)
@
\verb@MARSS()@ is automatically creating parameter names (since you did not tell it the names). To see exactly where each parameter element (e.g. \verb@Q.2@) appears in its parameter matrix, type \verb@summary(kemfit$model)@.

The default method is the Kalman-EM algorithm (\verb@method="kem"@).  You can use a quasi-Newton method\index{estimation!quasi-Newton} (BFGS) 
by setting \verb@method="BFGS"@\index{estimation!BFGS}.  The quasi-Newton method can be a bit fragile.  In fact, the BFGS method will generate numerical errors for this example.  
<<model-bfgs, include.source=FALSE>>=
kemfit.bfgs = MARSS(dat, method="BFGS")
@
If you wanted to use the Kalman-EM fit as the initial conditions\index{initial conditions!setting for BFGS}, pass in the \verb@inits@ argument.  
<< model-bfgs2, keep.source=TRUE, results=hide >>=
kemfit.bfgs2 = MARSS(dat, method="BFGS", inits=kemfit$par)
@
Output not shown, but this examples also happens to generate numerical errors.

\subsection{Five correlated hidden state processes}
This is the same model except that the hidden states have temporally correlated process errors.  Mathematically, this is the model:
\begin{gather*}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
= \begin{bmatrix}x_{1,t-1}\\x_{2,t-1}\\x_{3,t-1}\\x_{4,t-1}\\x_{5,t-1}\end{bmatrix}
+ \begin{bmatrix}u_1\\u_2\\u_3\\u_4\\u_5\end{bmatrix}
+ \begin{bmatrix}v_{1,t}\\v_{2,t}\\v_{3,t}\\v_{4,t}\\v_{5,t}\end{bmatrix}, 
 \textrm{ } \vv_t \sim \MVN\begin{pmatrix}0,
 \begin{bmatrix}q_1&c_{1,2}&c_{1,3}&c_{1,4}&c_{1,5}\\c_{1,2}&q_2&c_{2,3}&c_{2,4}&c_{2,5}\\
 c_{1,3}&c_{2,3}&q_3&c_{3,4}&c_{3,5}\\c_{1,4}&c_{2,4}&c_{3,4}&q_4&c_{4,5}\\
 c_{1,5}&c_{2,5}&c_{3,5}&c_{4,5}&q_5\end{bmatrix} \end{pmatrix} \\
\\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1&0&0&0&0\\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1\end{bmatrix}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
+ \begin{bmatrix}0\\0\\0\\0\\0\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix}, 
 \textrm{ } \ww_t \sim \MVN\begin{pmatrix} 0,\begin{bmatrix}r&0&0&0&0\\0&r&0&0&0\\0&0&r&0&0\\0&0&0&r&0\\0&0&0&0&r\end{bmatrix} \end{pmatrix}  \\
\end{gather*}
To fit, use \verb@MARSS()@\index{functions!MARSS} with the constraint argument set.  The output is not shown but it will appear if you type this on the R command line.
<<model-corr1, keep.source=TRUE, results=hide>>=
kemfit = MARSS(dat, constraint=list(Q="unconstrained"))
@

\subsection{Five equally correlated hidden state processes}
This is the same model except that now there is only one process error variance and one process error covariance.  Mathematically, the model is:
\begin{gather*}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
= \begin{bmatrix}x_{1,t-1}\\x_{2,t-1}\\x_{3,t-1}\\x_{4,t-1}\\x_{5,t-1}\end{bmatrix}
+ \begin{bmatrix}u_1\\u_2\\u_3\\u_4\\u_5\end{bmatrix}
+ \begin{bmatrix}v_{1,t}\\v_{2,t}\\v_{3,t}\\v_{4,t}\\v_{5,t}\end{bmatrix},
 \textrm{ } \ee_t \sim \MVN\begin{pmatrix} 0,
 \begin{bmatrix}q&c&c&c&c\\c&q&c&c&c\\c&c&q&c&c\\c&c&c&q&c\\c&c&c&c&q\end{bmatrix} \end{pmatrix} \\
\\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1&0&0&0&0\\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1\end{bmatrix}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
+ \begin{bmatrix}0\\0\\0\\0\\0\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix},
 \textrm{  } \ww_t \sim \MVN\begin{pmatrix} 0,\begin{bmatrix}r&0&0&0&0\\0&r&0&0&0\\0&0&r&0&0\\0&0&0&r&0\\0&0&0&0&r\end{bmatrix} \end{pmatrix}  \\
\end{gather*}
To fit, use the following code (output not shown):
<<model-corr2, include.source=F, keep.source=T, results=hide>>=
kemfit = MARSS(dat, constraint=list(Q="equalvarcov"))
@

\subsection{Five hidden state processes with a ``north'' and a ``south'' $u$ parameter}
Here we fit a model with five independent hidden states where each observation time series is an independent observation of a different hidden trajectory
but the hidden trajectories 1-3 share their $u$ and $q$ parameters, while hidden trajectories 4-5 share theirs.  This is the model:
\begin{gather*}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
= \begin{bmatrix}x_{1,t-1}\\x_{2,t-1}\\x_{3,t-1}\\x_{4,t-1}\\x_{5,t-1}\end{bmatrix}
+ \begin{bmatrix}u_n\\u_n\\u_n\\u_s\\u_s\end{bmatrix}
+ \begin{bmatrix}v_{1,t}\\v_{2,t}\\v_{3,t}\\v_{4,t}\\v_{5,t}\end{bmatrix},  
 \textrm{ } \vv_t \sim \MVN\begin{pmatrix} 0,\begin{bmatrix}q_n&0&0&0&0\\0&q_n&0&0&0\\0&0&q_n&0&0\\0&0&0&q_s&0\\0&0&0&0&q_s\end{bmatrix} \end{pmatrix}  \\
\\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1&0&0&0&0\\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1\end{bmatrix}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
+ \begin{bmatrix}0\\0\\0\\0\\0\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix},
 \textrm{ } \ww_t \sim \MVN\begin{pmatrix} 0,\begin{bmatrix}r&0&0&0&0\\0&r&0&0&0\\0&0&r&0&0\\0&0&0&r&0\\0&0&0&0&r\end{bmatrix} \end{pmatrix}  \\
\end{gather*}
To fit use the following code (output not shown):\index{functions!MARSS}
<<model-u-NS, keep.source=TRUE, results=hide>>=
regions=factor(c("N","N","N","S","S"))
kemfit = MARSS(dat, constraint=list(U=regions, Q=regions))
@

\subsection{Fixed observation error variance}
Here we fit the same model but with a known observation error variance.  This is the model:
\begin{gather*}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
= \begin{bmatrix}x_{1,t-1}\\x_{2,t-1}\\x_{3,t-1}\\x_{4,t-1}\\x_{5,t-1}\end{bmatrix}
+ \begin{bmatrix}u_n\\u_n\\u_n\\u_s\\u_s\end{bmatrix}
+ \begin{bmatrix}v_{1,t}\\v_{2,t}\\v_{3,t}\\v_{4,t}\\v_{5,t}\end{bmatrix},
 \textrm{ } \vv_t \sim \MVN\begin{pmatrix} 0,\begin{bmatrix}q_n&0&0&0&0\\0&q_n&0&0&0\\0&0&q_n&0&0\\0&0&0&q_s&0\\0&0&0&0&q_s\end{bmatrix} \end{pmatrix}  \\
\\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1&0&0&0&0\\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1\end{bmatrix}
\begin{bmatrix}x_{1,t}\\x_{2,t}\\x_{3,t}\\x_{4,t}\\x_{5,t}\end{bmatrix}
+ \begin{bmatrix}0\\0\\0\\0\\0\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix},  \\
\\
\ww_t \sim \MVN\begin{pmatrix} 0,\begin{bmatrix}0.01&0&0&0&0\\0&0.01&0&0&0\\0&0&0.01&0&0\\0&0&0&0.01&0\\0&0&0&0&0.01\end{bmatrix} \end{pmatrix} \\
\end{gather*}
To fit this model, use the following code (output not shown):\index{functions!MARSS}
<<model-u-NS-fixR, keep.source=TRUE, results=hide>>=
regions=factor(c("N","N","N","S","S"))
kemfit = MARSS(dat, constraint=list(U=regions, Q=regions,
          R=diag(0.01,5)))
@

\subsection{One hidden state and five i.i.d. observation time series}
Instead of five hidden state trajectories, we specify that there is only one and all the observations are of that one trajectory. Mathematically, the model is:
\begin{gather*}
x_{t}= x_{t-1} + u + v_{t}, \text{ } v_t \sim \N(0,q)  \\  \\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1\\1\\1\\1\\1\end{bmatrix}
x_{t} + \begin{bmatrix}0\\a_2\\a_3\\a_4\\a_5\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix},
 \textrm{ } \ww_t \sim \MVN\begin{pmatrix}0,\begin{bmatrix}r&0&0&0&0\\0&r&0&0&0\\0&0&r&0&0\\0&0&0&r&0\\0&0&0&0&r\end{bmatrix} \end{pmatrix}  \\
\end{gather*}
Note the default constraint for R is ``diagonal and equal'' so we can leave this off when specifying the \verb@constraint@ argument.  To fit, use this code (output not shown):
<<model-pan1, keep.source=TRUE>>=
kemfit =
   MARSS(dat, constraint=list(Z=factor(c(1,1,1,1,1))))
@

\subsection{One hidden state and five independent observation time series with different variances}
Mathematically, this model is:
\begin{gather*}
x_{t}= x_{t-1} + u + v_{t}, \text{ } v_t \sim \N(0,q)  \\
\\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1\\1\\1\\1\\1\end{bmatrix}
x_{t} + \begin{bmatrix}0\\a_2\\a_3\\a_4\\a_5\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix}, 
 \textrm{ } \ww_t \sim \MVN\begin{pmatrix} 0,\begin{bmatrix}r_1&0&0&0&0\\0&r_2&0&0&0\\0&0&r_3&0&0\\0&0&0&r_4&0\\0&0&0&0&r_5\end{bmatrix} \end{pmatrix}  \\
\end{gather*}
To fit this model:  \index{functions!MARSS}
<<model-pan2, keep.source=TRUE>>=
kemfit = 
   MARSS(dat, constraint=list(Z=factor(c(1,1,1,1,1)),
   R="diagonal and unequal"))
@

\subsection{Two hidden state processes}
Here we fit a model with two hidden states (north and south) where observation time series 1-3 are for the north and 4-5 are for the south.  We make the hidden state processes independent (meaning a diagonal $\QQ$ matrix) but with the same process variance.  We make the observation errors i.i.d. (the default) and the $\uu$ elements equal.  Mathematically, this is the model:
\begin{gather*}
\begin{bmatrix}x_{n,t}\\x_{s,t}\end{bmatrix}
= \begin{bmatrix}x_{n,t-1}\\x_{s,t-1}\end{bmatrix}
+ \begin{bmatrix}u\\u\end{bmatrix}
+ \begin{bmatrix}v_{n,t}\\v_{s,t}\end{bmatrix},   
 \textrm{ } \vv_t \sim \MVN\begin{pmatrix} 0,
 \begin{bmatrix}q&0\\0&q\end{bmatrix} \end{pmatrix} \\
\\
\begin{bmatrix}y_{1,t}\\y_{2,t}\\y_{3,t}\\y_{4,t}\\y_{5,t}\end{bmatrix}
= \begin{bmatrix}1&0\\1&0\\1&0\\0&1\\0&1\end{bmatrix}
\begin{bmatrix}x_{n,t}\\x_{s,t}\end{bmatrix}
+ \begin{bmatrix}0\\a_2\\a_3\\0\\a_5\end{bmatrix}
+ \begin{bmatrix}w_{1,t}\\ w_{2,t}\\ w_{3,t}\\ w_{4,t}\\ w_{5,t}\end{bmatrix}, 
 \textrm{ } \ww_t \sim \MVN\begin{pmatrix}0,\begin{bmatrix}r&0&0&0&0\\0&r&0&0&0\\0&0&r&0&0\\0&0&0&r&0\\0&0&0&0&r\end{bmatrix} \end{pmatrix}  \\
\end{gather*}
To fit the model, use the following code (output not shown):
<<model-two1, keep.source=TRUE, results=hide>>=
kemfit = 
   MARSS(dat, constraint=list(Z=factor(c("N","N","N","S","S")),
   Q="diagonal and equal",U="equal"))
@

\section{Printing and summarizing models and model fits}
The package includes print functions for marssm objects (model objects) and marssMLE objects (fitted models).\index{functions!summary}\index{MARSS model!print}
<<model-print, results=hide>>=
print(kemfit)
print(kemfit$model)
@
This will print the basic information on model structure and model fit that you have seen in the previous examples.

The package also includes a summary function for models.\index{MARSS model!summary}
<<model-summary, results=hide>>=
summary(kemfit$model)
@
Output is not shown because it is verbose, but it prints each matrix with the fixed elements denoted with their values and the free elements denoted by their names.  This is very helpful for confirming exactly what model structure you are fitting to the data.

\section{Confidence intervals on a fitted model}
The function \verb@MARSSparamCIs()@\index{functions!MARSSparamCIs} is used to compute confidence intervals.  The function can compute approximate confidence intervals using a numerically estimated Hessian matrix (\verb@method="hessian"@) or via parametric (\verb@method="parametric"@)   or non-parametric (\verb@method="innovations"@)  bootstrapping.

\subsection{Approximate confidence intervals from a Hessian matrix}
<<CIs-hessian, include.source=F, keep.source=T>>=
#default uses an est Hessian matrix
kem.with.hess.CIs = MARSSparamCIs(kemfit) 
@
Use \verb@print@ or just type the marssMLE object name to see the confidence intervals:
<<print-CIs>>=
print(kem.with.hess.CIs) 
@
\subsection{Confidence intervals from a parametric bootstrap}
Use \verb@method="parametric"@ to use a parametric bootstrap to compute confidence intervals and  bias using a parametric bootstrap. 
<<CIs-pboot, include.source=F, keep.source=T>>=
kem.w.boot.CIs=MARSSparamCIs(kemfit,method="parametric",nboot=10) 
#nboot should be more like 1000, but set low for example's sake
print(kem.w.boot.CIs)
@

\section{Vectors of just the estimated parameters}
Often it is useful to have a vector of the estimated parameters.  For example, if you are writing a call to \texttt{optim}, you will need a 
vector of just the estimated parameters\index{functions!MARSSvectorizeparam}.
<<parvec, include.source=F, keep.source=T>>=
parvec=MARSSvectorizeparam(kemfit)
parvec
@
If you want to replace the estimated parameter values with different values, you can use the same function:
<<parvec2, keep.source=TRUE>>=
parvec.new=parvec
parvec.new["Q.1"]=0.02; parvec.new["U.1"]=0.05
kem.new=MARSSvectorizeparam(kemfit, parvec.new)
@
Then you might want to find out the likelihood of the data using those new parameter values.  You compute that with the Kalman filter function \verb@MARSSkf()@\index{functions!MARSSkf}, sending it the data and the parameters as a list.                                   
<<like.parvec, keep.source=TRUE>>=
kf=MARSSkf(dat, kem.new$par, miss.value=-99)
kf$logLik
@

\section{Determine which variance elements have not converged}
If your data are short relative to the number of parameters you are estimating, then you are liable to find that one the parameter elements is degenerate (is zero).  Try the following:
<<like.kem.degen, include.source=F, keep.source=T>>=
dat.short = dat[,1:10]
kem.degen = MARSS(dat.short, silent=2)
@

This will print a short warning that the maximum number of iterations was reached before convergence (silent=2 means brief messages).  Type \verb@cat(kem.200$errors)@ to see which parameter(s) 
is not converging or you can use \verb@find.degenerate()@ to plot the log parameter value against the log iteration number to figure out
 which parameter is not converged (Figure \ref{fig:degenerate}).  Use \verb@kem.200@ because this plot needs at least 100 iterations to look good.  It might be that your tolerance is too high and if you just ran a few more iterations the variances will converge.  So first try setting \verb@control$maxit@ higher.
<<like.kem200, include.source=F, keep.source=TRUE>>=
kem.200 = MARSS(dat.short, control=list(maxit=1000), silent=2)
@
The problem still will not go away.

%~~~~~~~~~~~~~~~~~~~~~~~~~
\begin{figure}[htp]
\begin{center}
<<plot-degenerate, keep.source=TRUE, fig=TRUE, echo=TRUE>>=
find.degenerate(kem.200)
@
\end{center}
\caption{A diagnostic plot showing which diagonal variance elements are not converging.  This is a log-log plot of iteration versus the log of the variance estimate.  It should be flat.}
\label{fig:degenerate}
\end{figure}
%~~~~~~~~~~~~~~~~~~~~~~~~~

We can try a few other solutions.  First perhaps we are just trying to estimate too many variances.  We can try using only one variance value in $\QQ$ and one $u$ value in $\uu$:
<<like.kem200, include.source=F, keep.source=T>>=
kem.small=MARSS(dat.short,constraint=list(Q="diagonal and equal",
   U="equal"),silent=2)
@
No, we still get the convergence warning. There are simply not enough data to estimate both process and observation variances.  

If we just want the likelihood, could we set $\QQ$ to a fixed diagonal matrix with very, very small values on the diagonal? No.  For the EM algorithm, you cannot set $\QQ$ to a fixed small value because then $\uu$ would converge very, very slowly simply because of the nature of the $\uu$ update equations.  However, you can try a quasi-Newton method with $\QQ$ fixed small\footnote{It won't work so well with $\RR$ however because the likelihood surface becomes spiky for the $\pipi$ parameter (the initial $\xx$ values) and $\pipi$ will be poorly estimated leading to a poor likelihood value.}.  Here we use one $\QQ$ variance and fix it small.
<<like.bfgs.degen, keep.source=TRUE>>=
kem.bfgs.degen=MARSS(dat.short,constraint=list(
   Q=diag(1E-12,5),U="equal"),method="BFGS")
@
We could also just set the degenerate variances, the 2nd, 3rd and 4th elements on the diagonal of $\QQ$, to a small value and estimate the 1st and 5th elements on the diagonal:
<<like.bfgs.degen, include.source=F, keep.source=T>>=
kem.bfgs.degen=MARSS(dat.short,constraint=list(
   Q=diag(c(NA,1E-12,1E-12,1E-12,NA),5),U="equal"),method="BFGS")
@
Note that this gets us close to the correct likelihood, but is not quite right since really the degenerate diagonal elements should equal 0, but you cannot set them to zero because the likelihood calculation in the function \verb@MARSSkf()@ would throw an error.

\section{Bootstrap parameter estimates}
You can easily produce bootstrap parameter estimates from a fitted model using \verb@MARSSboot()@\index{functions!MARSSboot}: 
<<boot, keep.source=TRUE>>=
boot.params = MARSSboot(kemfit, 
     nboot=20, output="parameters", sim="parametric")$boot.params
@
Use \verb@silent=TRUE@ to stop the progress bar from printing. The function will also produce parameter sets generated using a Hessian matrix (\verb@sim="hessian"@) or a non-parametric bootstrap (\verb@sim="innovations"@).

\section{Data simulation}\index{simulation}
\subsection{Simulated data from a fitted MARSS model}
You can easily simulate data from a fitted model using \verb@MARSSsimulate()@\index{functions!MARSSsimulate}\index{simulation!MARSSsimulate function}. 
<<sim, include.source=F, keep.source=T>>=
sim.data=MARSSsimulate(kemfit$par, nsim=2, tSteps=100)$sim.data
@
Then you might want to estimate parameters from that simulated data.  Above we created two simulated datasets (\texttt{nsim=2}).  We will fit to the first one. Here the default settings for \verb@MARSS()@ are used.
<<sim-fit, include.source=F, keep.source=T, results=hide>>=
kem.sim.1 = MARSS(sim.data[,,1])
@
Then we might like to see the likelihood\index{likelihood} of the second set of simulated data under the model fit to the first set of data.  We do that with the Kalman filter function.\index{likelihood!MARSSkf function}
<<sim-like, include.source=F, keep.source=T>>=
MARSSkf(sim.data[,,2], kem.sim.1$par, miss.value = -99)$logLik
@
There are no missing values in our simulated data, but we still need to pass \verb@miss.value@ into \verb@MARSSkf()@.
\subsection{Simulated data from a user-built MARSS model}
This shows you how to build up a model from scratch and simulate from that using \verb@MARSSsimulate()@\index{functions!MARSSsimulate}\index{simulation!MARSSsimulate function}.  
<<sim-pp, keep.source=TRUE>>=
nsim = 20              # number of simulations
burn = 10              # length of burn in period
tSteps = 25            
m=3                    #number of hidden state trajectories
B = diag(1,m);
A = array(0, dim=c(m,1)) 
Z = diag(1,m) 
U = array(0.01, dim=c(m,1)) 
Q = diag(0.3, m)       #independent process errors 
R = diag(0.01, m)      #independent obs errors
x0 = array(10, dim=c(m,1)) #initial conditions, really x_1
V0 = array(0,dim=c(m,m))   #leave this 0
the.par.list = 
    list(Z=Z, A=A, R=R, B=B, U=U, Q=Q, x0=x0, V0=V0 )

# simulate data
sim = MARSSsimulate(the.par.list,nsim=nsim,tSteps=burn+tSteps)
# take off the burn
obs = sim$sim.data[,(burn+1):(burn+tSteps),] #m x T x nsim
@

\subsection{Correlation between estimated parameters}
We can use a \verb@for@ loop along with \texttt{MARSSvectorizeparam()}\index{functions!MARSSvectorizeparam} to estimate parameters for each of the \verb@nsim@ simulated datasets in \verb@obs@, and then assemble the estimates into a matrix.  
<<sim-pp2, results=hide>>=
for(i in 1:nsim){
dat=obs[,,i] 
kem.sim=MARSS(dat, silent=TRUE)
if(i==1) par.sim=MARSSvectorizeparam(kem.sim)
else par.sim=rbind(par.sim, MARSSvectorizeparam(kem.sim))
}
@ 
<<tesing-par-corrs, fig=FALSE, results=hide, echo=FALSE>>=
pairs(par.sim)
@
Then we use \verb@pairs()@ to get a quick visual look at how the parameters are correlated (or not) and how variable they are (Figure \ref{fig:QE-pairs}).
%~~~~~~~~~~~~~~~~~~~~~~~~~
\begin{figure}[htp]
\begin{center}
<<plot-par-corrs, keep.source=T, fig=TRUE, echo=FALSE>>=
pairs(par.sim)
@
\end{center}
\caption{The parameter pairs plotted against each other using the command \texttt{pairs(par.sim)}.}
\label{fig:QE-pairs}
\end{figure}
%~~~~~~~~~~~~~~~~~~~~~~~~~

We could also use \verb@MARSSboot()@\index{functions!MARSSboot}\index{bootstrap!MARSSboot function} to do this.  However, \verb@MARSSboot()@ is designed to take a marssMLE object\index{objects!marssMLE} (such as would be returned from \verb@MARSS()@).  

\section{Bootstrap AIC} 
The function \verb@MARSSaic()@\index{model selection!MARSSaic function}\index{functions!MARSSaic} computes a bootstrap AIC for model selection purposes.  Use \verb@output="AICbp"@ to produce a parameter bootstrap\index{model selection!bootstrap AIC, AICbp}.  Use \verb@output="AICbb"@ to produce a non-parameter bootstrap\index{model selection!bootstrap AIC, AICbb} AIC.
<<AICb, keep.source=TRUE>>= 
kemfit.with.AICb = MARSSaic(kemfit, output = "AICbp", 
   Options = list(nboot = 10, silent=TRUE))
#nboot should be more like 1000, but set low here for example sake

print(kemfit.with.AICb)
@

<<reset, echo=F, include.source=F>>=
options(prompt="> ", continue=" +", width=120)
@